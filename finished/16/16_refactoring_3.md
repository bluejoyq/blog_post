# [소프트웨어 공학]리팩터링 3장
전 단원에서는 리팩터링의 전반적인 원칙에 대해 배웠다. 이번에는 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 법을 배워볼 것이다.
리팩터링할 시점을 설명하는데에 `냄새`란 표현을 사용한다. 냄새가 나는 시작 시점을 찾는 법을 알아본다. 그리고 종료할 시점보다는 리팩터링하면 해결할 문제의 징후를 표현하겠다.
*(이게 진짜 무슨 소리냐)*
## 3.1 리팩터링의 정의
코드를 명료하게 표현하는데 가장 중요한 요소 하나는 `이름`이다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 무슨 일을 하고 어떻게 사용할지 명확히 알도록 이름을 지어야 한다.

그러나 이름 짓기는 정말 어렵다. 그렇기에 우리가 가장 많이 사용하는 리팩터링 `함수 선언 바꾸기`, `변수 이름 바꾸기`, `필드 이름 바꾸기`처럼 이름을 바꾸는 리팩터링들이다. 

마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 있다. 그러므로 혼란스러운 이름을 잘 정리해서 코드를 간결하게 만들자.

### 코멘트
이름 짓는건 정말 어렵다. 영어 공부를 좀 해야지 어휘 폭이 넓어질 듯.

## 3.2 중복 코드
똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합해 더 나은 프로그램을 만들 수 있다.

## 3.3 긴 함수
### 짧은 함수의 중요성
짧은 함수들로 이루어진 프로그램은 `간접 호출(indirection)`의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점을 가진다. 

예전에는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸다. 그렇지만 지금은 ㄱㅊ.

코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야하므로 여전히 부담이 되지만 함수 선언부와 호출부를 빠르게 이동하거나 동시에 보여주는 개발 환경을  활용하면 이 부담이 줄어든다. 하지만 짧은 함수로 구성된 코드를 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. **함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.**

적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 그 함수 본문에는 원래 주석으로 설명하려던 코드를 담고, **함수 이름은 동작 방식이 아닌 `의도(intention)`이 드러나게 짓는다.**

원래 코드보다 길어지더라도 함수로 뽑아야 한다. 단, 함수 이름에 코드의 목적을 드러내야 한다. 무엇을 하는지를 코드가 잘 설명해주지 못할 수록 함수로 만드는 게 유리하다.

### 짧은 함수 만들기
함수를 짧게 만드는 작업으 99%는 `함수 추출하기`가 차지한다. 함수 본문에서 따로 묶어 빼면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다. *(테스트에도 방해가 되겠죠!)* 그러므로 `임시 변수를 질의 함수로 바꾸기`로 임시 변수의 수를, `매개변수 객체 만들기`와 `객체 통째로 넘기기`로 매개변수의 수를 줄이자.

이 리팩터링을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라 할 수 있는 `함수를 명령으로 바꾸기`를 고려해보자.

### 추출할 코드 찾기
좋은 방법은 주석을 참고하는 것이다. 주석은 코드만으로 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. 이런 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다. 

**코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.**

조건문이나 반복문도 추출 대상의 실마리를 제공한다. 조건문은 `조건문 분해하기`로 대응한다. 거대한 switch문을 구성하는 case문마다 `함수 추출하기`를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 `조건문을 다형성으로 바꾸기`를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업을 섞여 있기 때문일 수 있다. 이럴 때는 `반복문 쪼개기`를 적용해서 작업을 분리한다.

### 코멘트
뼈가 되고 살이 되는 조언인듯.

## 3.4 긴 매개변수 목록
### 과거
예전에는 함수에 필요한 것을 모조리 매개변수로 전달하라고 배웠다. 그래야 전역 데이터가 늘어나는 사태를 막을 수 있기 때문이다.
그러나 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.

### 개선하기
- 종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개 변수는 `매개 변수를 질의 함수로 바꾸기`로 제가할 수 있다. *(그러면 i/o 작업이나 통신 작업은 당연히 예외겠지?!))*
- 사용 중인 데이터 구조에서 값을을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 `객체 통째로 넘기기`를 적용해서 원본 데이터 구조를 그대로 전달한다.
- 항상 함꼐 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어버린다.
- 함수의 동작 방식을 정하는 플래그 역활의 매개 변수는 `플로그 인수 제거하기`로 없애준다.
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때는 `여러 함수를 클래스로 묶기`를 이용해 공통 값들을 클래스의 필르로 정의한다. 함수형 프로그래밍이었다면 일련의 `부분 적용 함수(partially applied function)`들을 생성한다고 말했을 것이다.

### 코멘트
부분 적용 함수 : https://velog.io/@kwonh/ES6-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98-%EC%BB%A4%EB%A7%81-%EB%B6%80%EB%B6%84%EC%A0%81%EC%9A%A9%ED%95%A8%EC%88%98 이게 무슨 소리지?

## 3.5 전역 데이터
### 나쁜 전역 데이터
전역 데이터를 주의해야 한다. 전역 데이터는 코드 베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제다.
문제가 생기면, 그 원인이 되는 코드를 찾아내기도 힘들다.

### 방지하기
이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 `변수 캡슐화하기`다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용하자. 
이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고, 접근을 통제할 수 있다. 더 나아가 접근자 함수를 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

### 더나아가
전역 데이터가 가변이라면 특히 다루기 까다롭다. 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다. *(고정 상수 값 변수 사용 가능?!)* 전역 데이터가 아주 조금만 있더라도 캡슐화 하자 소프트웨어가 진화하는데에 따르는 변화에 대처할 수 있다.

### 코멘트
그러면 다량의 비밀키? ex) env파일의 정보 같은 경우에는 전역으로 관리하지말고 한번 불러서 사용해야하나?

## 3.6 가변 데이터
### 함수형 프로그래밍에서의 불변 데이터
데이터를 변경하면 예기치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다. 이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.
그러나 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고, 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머가 더 많다. 

### 나머지 언어에서의 불변 데이터
불변성이 주는 장점을 포기하지 않고 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
- `변수 캡슐화하기`를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 
- 갱신 로직은 다른 코드와 떨어트려 놓자. `문장 슬라이드하기`와 `함수 추출하기`를 이용해 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리하자.
- API를 만들 때는 `질의 함수와 변경 함수 분리하기`를 활용해서 꼭 필요한 경우가 아니라면 붑작용이 있는 코드를 호출 못하게 한다.
- 가능한 `세터 제거하기`도 적용한다. *(접근자랑은 분위기가 다르네)* 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는데 도움될 때가 있다.

### 가변 데이터를 바꾸기 
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 좋지 않다. `파생 변수를 질의 함수로 바꾸기`로 코드 전체를 적절히 바꿔주자.
- 변수의 유효 범위가 좁다면 가변 데이터여도 문제가 적다. 그래도 `여러 함수를 클래스를 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해 코드의 유효 범위를 (클래스나 변환으로) 제한하자.
- 구조체처럼 내부 필드에 데이터를 담고 있다면 *(js obejct나 python dict?)* `참조를 값으로 바꾸기`를 적용하여, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다. 

### 코멘트
구조체랑 object나 dict가 다르게 작동하나? 전부 첫 주소만 보내는거 아닌가욤

## 3.7 뒤엉킨 변경 
소프트웨어의 구조를 변경하기 쉬운 형태로 조직해야한다. 코드를 수정할 때는 시스템에서 고쳐야할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.이렇게 할 수 없다면 `뒤엉킨 변경`과 `산탄총 수술` 중 하나가 풍긴다.

### 뒤엉킨 변경이 나타날 때
뒤엉킨 변경은 `단일 책임 원칙(SRP)`가 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 개발 초기에는 맥락 사이의 경계를 명확히 나누기가 어렵고, 소프트웨어 시스템의 기능이 변경되면서 이 경계도 끊임없이 움직이기에 나중에야 이 악취가 느껴질 수도 있다.

### 해결하기
- 순차적으로 실행되는게 자연스러운 맥락이라면 (db에서 데이터 꺼내서 처리하기), 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다(`단계 쪼개기`). 
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다(`함수 옮기기`)
- 여려 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 `함수 추출하기`부터 수행한다. 모듈이 클래스라면 `클래스 추출하기`.

### 코멘트 
x

## 3.8 산탄총 수술
### 산탄총 수술과 뒤엉킨 변경
`산탄총 수술`은 `뒤엉킨 변경`과 비슷하면서도 정반대이다.
|제목|내용|설명|
|------|---|---|
|원인|맥락을 잘 구분하지 못함|맥락을 잘 구분하지 못함|
|해결(원리)|맥락을 명확히 구분|맥락을 명확히 구분|
|발생 과정(현상)|한 코드에 섞여 들어감|여러 코드에 흩뿌려짐|
|해법(실제 행동)|맥락별로 분리|맥락별로 모음|

### 원인
코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생한다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

### 해결법
- 함께 변경되는 대상들을 `함수 옮기기`와 `필드 옮기기`로 모두 한 모듈에 묶어두면 좋다. 
- 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기`를 적용한다.
- 데이터 구조를 변환하거나 보강하는 함수들에는 `여러 함수를 변환 함수로 묶기`를 적용한다.
- 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용한다.
- 어설프게 분리한 로직을 `함수 인라인하기`나 `클래스 인라인하기` 같은 인라인 팩터링으로 하나로 합치는 것도 좋은 방법이다.

코드가 비대해지더라도 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다. 작은 함수와 클래스에 집착해야하지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐져도 괜찮다.

### 코멘트
뒤에 기술들을 좀 봐야지 이해가 될듯~

## 3.9 기능 편애
프로그램을 모듈화하면 코드를 여러 영역으로 나누고, 영역 내의 상호작용은 최대한 늘리고, 영역 사이의 상호작용은 최소로 줄이는 데 주력한다.

### 기능 편애란?
기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새다.

### 해결법
- 함수가 데이터와 가까이 있고 싶어 한다면 데이터 근처로 옮기자(`함수 옮기기`).
- 함수의 일부에서만 기능을 편애한다면 그 부분만 독립 함수로 빼내(`함수 추출하기`) 원하는 모듈로 보내준다(`함수 옮기기`).

### 어디로 옮겨야 할지 모를 때
함수가 사양하는 모듈이 다양하다면 가장 많은 데이터를 포함한 모듈로 옮기자.
`함수 추출하기`로 함수를 여러 조각으로 나눠 각각을 적합한 모듈로 옮겨도 된다.

### 복잡한 패턴의 경우
`전략 패턴(Strategy pattern)`과 `방문자 패턴(Visitor Pattern)`, `자기 위임(Self-Delegation)`도 여기 속한다. 
이들은 모두 `뒤엉킨 변경` 냄새를 없앨 때 활용하는 패턴들로, 가장 기본이 되는 원칙은 '함께 변경될 대상을 한데 모으는 것'이다. 
데이터와 이를 활용하는 동작은 함께 변경해야 할 때가 많지만, 예외가 있다. 그럴 때는 같은 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다. 

### 코멘트
전략 패턴 https://victorydntmd.tistory.com/292
방문자 패턴 https://dailyheumsi.tistory.com/216
자기 위임은 없네...

## 3.10 데이터 뭉치
데이터 항목들은 어울리는걸 좋아한다. 물려다니는 데이터 뭉치는 따로 묶어줘야한다.

### 방법
- 가장 먼저 필드 형태의 데이터 뭉치를 찾아서 `클래스 추출하기`로 하나의 객체로 묶는다.
- 이후 메서드 시그니처 *(이게 뭔데)* 있는 데이터 뭉치를 `매개 변수 객체 만들기`나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여본다. 

### 클래스 권장
방금 설명에서 간단한 레코드 구조가 아닌 클래스로 만들기를 권고 했다. 새로운 클래스를 만들고 그 클래스로 옮기기 좋은 동작을 살펴보자. 이렇게 데이터 뭉치를 생산성에 기여하는 정식 멤버로 만들자.